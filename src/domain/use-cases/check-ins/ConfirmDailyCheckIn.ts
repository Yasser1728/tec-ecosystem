/**
 * Confirm Daily CheckIn Use Case - TEC Assistant Domain
 * Records user's daily check-in and updates gamification
 */

import { CheckIn } from "../../entities/CheckIn";
import { ICheckInRepository } from "../../interfaces/repositories/ICheckInRepository";
import { IUserRepository } from "../../interfaces/repositories/IUserRepository";
import { ISignalRepository } from "../../interfaces/repositories/ISignalRepository";
import { TEC_ASSISTANT_CONFIG } from "../../../shared/config/features";

export interface ConfirmDailyCheckInInput {
  userId: string;
}

export interface ConfirmDailyCheckInOutput {
  checkIn: CheckIn;
  xpEarned: number;
  newStreak: number;
  leveledUp: boolean;
}

export class ConfirmDailyCheckIn {
  constructor(
    private checkInRepository: ICheckInRepository,
    private userRepository: IUserRepository,
    private signalRepository: ISignalRepository,
  ) {}

  async execute(
    input: ConfirmDailyCheckInInput,
  ): Promise<ConfirmDailyCheckInOutput> {
    const today = this.getStartOfDay(new Date());

    // Check if already checked in today
    const existingCheckIn = await this.checkInRepository.findByUserAndDate(
      input.userId,
      today,
    );

    if (existingCheckIn) {
      throw new Error("Already checked in today");
    }

    // Get user
    const user = await this.userRepository.findById(input.userId);
    if (!user) {
      throw new Error("User not found");
    }

    // Get today's signal
    const signal = await this.signalRepository.findByDate(today);
    if (!signal) {
      throw new Error("Signal not found for today");
    }

    // Calculate streak
    const latestCheckIn = await this.checkInRepository.findLatestByUserId(
      input.userId,
    );
    const newStreak = this.calculateStreak(
      latestCheckIn?.date,
      today,
      user.currentStreak,
    );

    // Calculate XP based on streak
    const xpEarned = this.calculateXp(newStreak);

    // Record check-in
    const checkIn = new CheckIn({
      id: "", // Will be generated by repository
      userId: input.userId,
      date: today,
      signal: signal.type,
      xpEarned,
      streakDay: newStreak,
      createdAt: new Date(),
    });

    const createdCheckIn = await this.checkInRepository.create(checkIn);

    // Update user gamification
    const previousLevel = user.level;
    user.updateStreak(newStreak);
    user.addXp(xpEarned);
    await this.userRepository.update(user);

    const leveledUp = user.level > previousLevel;

    return {
      checkIn: createdCheckIn,
      xpEarned,
      newStreak,
      leveledUp,
    };
  }

  /**
   * Calculate streak based on last check-in
   */
  private calculateStreak(
    lastCheckInDate: Date | undefined,
    today: Date,
    currentStreak: number,
  ): number {
    if (!lastCheckInDate) {
      return 1; // First check-in
    }

    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = this.getStartOfDay(yesterday).toISOString();
    const lastCheckInStr = this.getStartOfDay(lastCheckInDate).toISOString();

    if (lastCheckInStr === yesterdayStr) {
      // Consecutive day
      return currentStreak + 1;
    } else {
      // Streak broken
      return 1;
    }
  }

  /**
   * Calculate XP earned based on streak
   */
  private calculateXp(streak: number): number {
    const baseXp = TEC_ASSISTANT_CONFIG.BASE_XP;
    const streakBonus = streak * TEC_ASSISTANT_CONFIG.STREAK_MULTIPLIER;
    return baseXp + streakBonus;
  }

  /**
   * Get start of day (midnight)
   */
  private getStartOfDay(date: Date): Date {
    const newDate = new Date(date);
    newDate.setHours(0, 0, 0, 0);
    return newDate;
  }
}
